import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

class ProductionOptimizer:
    def __init__(self):
        self.lead_time_df = None
        self.demand_df = None
        self.stock_df = None
        self.bottleneck_df = None
        self.machine_df = None
        self.stock_demand_df = None
        
    def load_business_logic_outputs(self):
        """Load all CSV files generated by business logic"""
        required_files = [
            "lead_time_analysis.csv",
            "demand_analysis.csv", 
            "live_stock_analysis.csv",
            "bottleneck_analysis.csv",
            "machine_availability.csv",
            "stock_vs_demand.csv"
        ]
        
        missing_files = []
        for file in required_files:
            try:
                if file == "lead_time_analysis.csv":
                    self.lead_time_df = pd.read_csv(file)
                elif file == "demand_analysis.csv":
                    self.demand_df = pd.read_csv(file)
                elif file == "live_stock_analysis.csv":
                    self.stock_df = pd.read_csv(file)
                elif file == "bottleneck_analysis.csv":
                    self.bottleneck_df = pd.read_csv(file)
                elif file == "machine_availability.csv":
                    self.machine_df = pd.read_csv(file)
                elif file == "stock_vs_demand.csv":
                    self.stock_demand_df = pd.read_csv(file)
                print(f" Loaded {file}")
            except FileNotFoundError:
                missing_files.append(file)
                print(f" Missing {file}")
        
        if missing_files:
            print(f"\n MISSING FILES: {', '.join(missing_files)}")
            print("Please run the business logic script first:")
            print("   python business_logic.py")
            return False
        
        print(" All business logic files loaded successfully")
        return True
    
    def predict_production_delays(self):
        """Predict which items will be delayed based on current bottlenecks"""
        if self.bottleneck_df is None or self.lead_time_df is None:
            return pd.DataFrame()
        
        delay_predictions = []
        
        # Get high-risk processes (convert to strings)
        high_risk_processes = [str(code) for code in self.bottleneck_df[
            self.bottleneck_df['BOTTLENECK_RISK'] == 'High'
        ]['PROCESS_CODE'].tolist()]
        
        # Check each item's routing for bottleneck processes
        for _, item in self.lead_time_df.iterrows():
            bottleneck_processes = str(item['BOTTLENECK_PROCESSES'])
            
            # Check if item routing contains high-risk processes
            delay_risk = "Low"
            predicted_delay_days = 0
            
            for process in high_risk_processes:
                if str(process) in bottleneck_processes:
                    # Get average aging for this process
                    process_data = self.bottleneck_df[
                        self.bottleneck_df['PROCESS_CODE'].astype(str) == str(process)
                    ]
                    if not process_data.empty:
                        avg_aging = process_data.iloc[0]['AVG_AGING_DAYS']
                        predicted_delay_days = max(predicted_delay_days, avg_aging)
                        
                        if avg_aging > 45:
                            delay_risk = "High"
                        elif avg_aging > 30:
                            delay_risk = "Medium"
            
            delay_predictions.append({
                'ITEM_CODE': item['ITEM_CODE'],
                'STANDARD_LEAD_TIME': item['LEAD_TIME_SERIAL'],
                'PREDICTED_DELAY_DAYS': round(predicted_delay_days, 1),
                'PREDICTED_TOTAL_TIME': round(item['LEAD_TIME_SERIAL'] + predicted_delay_days, 1),
                'DELAY_RISK': delay_risk,
                'BOTTLENECK_PROCESSES': bottleneck_processes,
                'DELAY_REASON': f"Bottleneck in processes: {bottleneck_processes}" if delay_risk != "Low" else "No significant delays expected"
            })
        
        return pd.DataFrame(delay_predictions)
    
    def generate_production_schedule(self, days_ahead=30):
        """Generate optimal production schedule for next 30 days"""
        if self.stock_demand_df is None or self.demand_df is None:
            return pd.DataFrame()
        
        schedule = []
        today = datetime.now()
        
        # Priority 1: Out of stock items with open demand
        out_of_stock = self.stock_demand_df[
            self.stock_demand_df['STOCK_ADEQUACY'] == 'Out of Stock'
        ]
        
        # Priority 2: Shortage items
        shortage_items = self.stock_demand_df[
            self.stock_demand_df['STOCK_ADEQUACY'] == 'Shortage'
        ]
        
        priority_counter = 1
        
        # Schedule out of stock items first
        for _, item in out_of_stock.iterrows():
            if pd.notna(item['TOTAL_OPEN']) and item['TOTAL_OPEN'] > 0:
                # Get lead time for this item
                lead_time_data = self.lead_time_df[
                    self.lead_time_df['ITEM_CODE'] == item['ITEM_CODE']
                ]
                
                if not lead_time_data.empty:
                    lead_time = lead_time_data.iloc[0]['LEAD_TIME_SERIAL']
                    start_date = today + timedelta(days=1)
                    end_date = start_date + timedelta(days=lead_time)
                    
                    schedule.append({
                        'PRIORITY': priority_counter,
                        'ITEM_CODE': item['ITEM_CODE'],
                        'QUANTITY_NEEDED': item['TOTAL_OPEN'],
                        'START_DATE': start_date.strftime('%Y-%m-%d'),
                        'END_DATE': end_date.strftime('%Y-%m-%d'),
                        'LEAD_TIME_DAYS': lead_time,
                        'URGENCY': 'CRITICAL - Out of Stock',
                        'REASON': f"Customer demand: {item['TOTAL_OPEN']} units, Current stock: 0"
                    })
                    priority_counter += 1
        
        # Schedule shortage items
        for _, item in shortage_items.iterrows():
            shortage_qty = item['SHORTAGE_QTY']
            if pd.notna(shortage_qty) and shortage_qty > 0:
                lead_time_data = self.lead_time_df[
                    self.lead_time_df['ITEM_CODE'] == item['ITEM_CODE']
                ]
                
                if not lead_time_data.empty:
                    lead_time = lead_time_data.iloc[0]['LEAD_TIME_SERIAL']
                    start_date = today + timedelta(days=priority_counter)
                    end_date = start_date + timedelta(days=lead_time)
                    
                    schedule.append({
                        'PRIORITY': priority_counter,
                        'ITEM_CODE': item['ITEM_CODE'],
                        'QUANTITY_NEEDED': shortage_qty,
                        'START_DATE': start_date.strftime('%Y-%m-%d'),
                        'END_DATE': end_date.strftime('%Y-%m-%d'),
                        'LEAD_TIME_DAYS': lead_time,
                        'URGENCY': 'HIGH - Shortage',
                        'REASON': f"Shortage: {shortage_qty} units needed"
                    })
                    priority_counter += 1
        
        return pd.DataFrame(schedule)
    
    def forecast_inventory_needs(self, days_ahead=90):
        """Forecast inventory requirements for next 90 days"""
        if self.demand_df is None:
            return pd.DataFrame()
        
        forecasts = []
        
        for _, item in self.demand_df.iterrows():
            # Calculate demand velocity (units per day)
            recent_demand = item['RECENT_DEMAND_90D'] if pd.notna(item['RECENT_DEMAND_90D']) else 0
            daily_demand = recent_demand / 90 if recent_demand > 0 else 0
            
            # Get current stock
            current_stock = 0
            if self.stock_df is not None:
                stock_data = self.stock_df[
                    self.stock_df['ITEM_CODE'] == item['ITEM_CODE']
                ]
                if not stock_data.empty:
                    current_stock = stock_data['AVAILABLE_QTY'].sum()
            
            # Calculate when stock will run out
            days_until_stockout = float('inf')
            if daily_demand > 0:
                days_until_stockout = current_stock / daily_demand
            
            # Forecast needed production
            forecasted_demand = daily_demand * days_ahead
            production_needed = max(0, forecasted_demand - current_stock)
            
            # Get lead time for planning
            lead_time = 0
            if self.lead_time_df is not None:
                lead_time_data = self.lead_time_df[
                    self.lead_time_df['ITEM_CODE'] == item['ITEM_CODE']
                ]
                if not lead_time_data.empty:
                    lead_time = lead_time_data.iloc[0]['LEAD_TIME_SERIAL']
            
            # Determine urgency
            urgency = "Low"
            if days_until_stockout <= lead_time:
                urgency = "Critical"
            elif days_until_stockout <= lead_time * 2:
                urgency = "High"
            elif days_until_stockout <= lead_time * 3:
                urgency = "Medium"
            
            forecasts.append({
                'ITEM_CODE': item['ITEM_CODE'],
                'CURRENT_STOCK': current_stock,
                'DAILY_DEMAND': round(daily_demand, 2),
                'DAYS_UNTIL_STOCKOUT': round(days_until_stockout, 1) if days_until_stockout != float('inf') else 999,
                'FORECASTED_DEMAND_90D': round(forecasted_demand, 0),
                'PRODUCTION_NEEDED': round(production_needed, 0),
                'LEAD_TIME_DAYS': lead_time,
                'URGENCY': urgency,
                'RECOMMENDED_ACTION': f"Start production in {max(0, days_until_stockout - lead_time):.0f} days" if days_until_stockout != float('inf') else "Monitor demand"
            })
        
        return pd.DataFrame(forecasts)
    
    def optimize_machine_allocation(self):
        """Suggest optimal machine allocation based on bottlenecks"""
        if self.machine_df is None or self.machine_df.empty:
            return pd.DataFrame()
        
        allocations = []
        
        for _, machine in self.machine_df.iterrows():
            process_code = machine['PROCESS_CODE']
            status = machine['AVAILABILITY_STATUS']
            utilization = machine['UTILIZATION_PCT']
            
            # Generate recommendations
            if status == "Overloaded":
                recommendation = "URGENT: Add capacity, redistribute workload, or work overtime"
                action = "Immediate intervention required"
            elif status == "High Load":
                recommendation = "Monitor closely, consider adding shift or equipment"
                action = "Plan capacity increase"
            elif status == "Medium Load":
                recommendation = "Optimal utilization, monitor for changes"
                action = "Continue current operations"
            else:
                recommendation = "Available for additional work"
                action = "Can take on more jobs"
            
            allocations.append({
                'PROCESS_CODE': process_code,
                'CURRENT_STATUS': status,
                'UTILIZATION_PCT': utilization,
                'TOTAL_JOBS': machine['TOTAL_JOBS'],
                'CRITICAL_JOBS': machine['CRITICAL_JOBS'],
                'EMPLOYEES_ASSIGNED': machine['EMPLOYEES_ASSIGNED'],
                'RECOMMENDATION': recommendation,
                'ACTION_REQUIRED': action,
                'PRIORITY': 'HIGH' if status in ['Overloaded', 'High Load'] else 'MEDIUM' if status == 'Medium Load' else 'LOW'
            })
        
        return pd.DataFrame(allocations)
    
    def run_optimization(self):
        """Run complete production optimization"""
        print(" PRODUCTION OPTIMIZATION ALGORITHM")
        print("=" * 50)
        
        # Load data
        if not self.load_business_logic_outputs():
            print("\n Cannot proceed without business logic files.")
            print("Please run: python business_logic.py")
            return
        
        # 1. Delay Predictions
        print("\n 1. DELAY PREDICTIONS")
        print("-" * 30)
        delays_df = self.predict_production_delays()
        if not delays_df.empty:
            print(delays_df.head(10))
            delays_df.to_csv("delay_predictions.csv", index=False)
            
            high_risk_delays = len(delays_df[delays_df['DELAY_RISK'] == 'High'])
            print(f"\n High Risk Delays: {high_risk_delays}")
        else:
            print("No delay predictions available")
        
        # 2. Production Schedule
        print("\n 2. PRODUCTION SCHEDULE (Next 30 Days)")
        print("-" * 30)
        schedule_df = self.generate_production_schedule()
        if not schedule_df.empty:
            print(schedule_df.head(10))
            schedule_df.to_csv("production_schedule.csv", index=False)
            
            critical_items = len(schedule_df[schedule_df['URGENCY'].str.contains('CRITICAL', na=False)])
            print(f"\n Critical Items to Start: {critical_items}")
        else:
            print("No production schedule items")
        
        # 3. Inventory Forecast
        print("\n 3. INVENTORY FORECAST (Next 90 Days)")
        print("-" * 30)
        forecast_df = self.forecast_inventory_needs()
        if not forecast_df.empty:
            print(forecast_df.head(10))
            forecast_df.to_csv("inventory_forecast.csv", index=False)
            
            critical_forecasts = len(forecast_df[forecast_df['URGENCY'] == 'Critical'])
            print(f"\n Critical Inventory Needs: {critical_forecasts}")
        else:
            print("No inventory forecasts available")
        
        # 4. Machine Allocation
        print("\n 4. MACHINE ALLOCATION OPTIMIZATION")
        print("-" * 30)
        allocation_df = self.optimize_machine_allocation()
        if not allocation_df.empty:
            print(allocation_df.head(10))
            allocation_df.to_csv("machine_allocation.csv", index=False)
            
            high_priority_machines = len(allocation_df[allocation_df['PRIORITY'] == 'HIGH'])
            print(f"\n High Priority Machine Issues: {high_priority_machines}")
        else:
            print("No machine allocation data available")
        
        print("\n Optimization complete! Files saved:")
        print("   - delay_predictions.csv")
        print("   - production_schedule.csv")
        print("   - inventory_forecast.csv")
        print("   - machine_allocation.csv")

if __name__ == "__main__":
    optimizer = ProductionOptimizer()
    optimizer.run_optimization()
